<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro CRT Interactive Terminal</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --phosphor-main: #39ff14;
            --phosphor-dim: #1b8a0a;
            --bg-color: #050505;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevents zooming/scrolling on mobile */
        }

        /* Container for the CRT Effect */
        #crt-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--bg-color);
            overflow: hidden;
        }

        /* The actual game canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            filter: blur(0.5px) contrast(1.2) brightness(1.1);
        }

        /* Scanlines Overlay */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0),
                rgba(255, 255, 255, 0) 50%,
                rgba(0, 0, 0, 0.2) 50%,
                rgba(0, 0, 0, 0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* Vignette & Screen Curve Illusion */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle,
                rgba(0, 0, 0, 0) 60%,
                rgba(0, 0, 0, 0.6) 90%,
                rgba(0, 0, 0, 1) 100%
            );
            pointer-events: none;
            z-index: 11;
            box-shadow: inset 0 0 5rem rgba(0,0,0,0.7);
        }

        /* Screen Flicker Animation */
        .flicker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(57, 255, 20, 0.02);
            opacity: 0;
            pointer-events: none;
            z-index: 9;
            animation: flickerAnim 0.15s infinite;
        }

        @keyframes flickerAnim {
            0% { opacity: 0.01; }
            50% { opacity: 0.05; }
            100% { opacity: 0.01; }
        }

        /* Start Overlay */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20;
            color: var(--phosphor-main);
            text-align: center;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px var(--phosphor-main);
            letter-spacing: 5px;
        }

        p {
            font-size: 1.5rem;
            opacity: 0.8;
        }

        button {
            margin-top: 2rem;
            padding: 1rem 2rem;
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            background: transparent;
            color: var(--phosphor-main);
            border: 2px solid var(--phosphor-main);
            cursor: pointer;
            box-shadow: 0 0 10px var(--phosphor-dim);
            transition: all 0.2s;
        }

        button:hover {
            background: var(--phosphor-main);
            color: black;
            box-shadow: 0 0 20px var(--phosphor-main);
        }

        button:active {
            transform: scale(0.95);
        }

        /* Text Flicker Effect */
        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }
        
        .ui-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--phosphor-main);
            font-size: 1.2rem;
            z-index: 12;
            pointer-events: none;
            text-shadow: 0 0 4px var(--phosphor-dim);
        }

        .ui-score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: var(--phosphor-main);
            font-size: 1.2rem;
            z-index: 12;
            pointer-events: none;
            text-align: right;
            text-shadow: 0 0 4px var(--phosphor-dim);
        }

        .keyboard-hints {
            font-size: 1rem;
            margin-top: 2rem;
            opacity: 0.6;
        }

        /* Auto-fire notification - positioned compactly on screen */
        .auto-fire-notification {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--phosphor-main);
            font-size: 1rem;
            z-index: 15;
            pointer-events: none;
            text-shadow: 0 0 8px var(--phosphor-main);
            padding: 6px 12px;
            border: 1px solid var(--phosphor-main);
            background: rgba(0, 0, 0, 0.7);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .auto-fire-notification.visible {
            opacity: 1;
        }

        .auto-fire-notification.fade-out {
            opacity: 0;
        }

    </style>
</head>
<body>

<div id="crt-container">
    <div class="flicker"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>
    
    <div class="ui-stats">
        SYSTEM: ONLINE<br>
        FPS: <span id="fps-counter">60</span><br>
        AUDIO: <span id="audio-status">OFFLINE</span>
    </div>

    <div class="ui-score">
        SCORE: <span id="score">0000</span><br>
        WAVE: <span id="wave">01</span>
    </div>

    <div id="auto-fire-notification" class="auto-fire-notification"></div>

    <canvas id="gameCanvas"></canvas>

    <div id="start-overlay">
        <h1>// SYSTEM_BOOT //</h1>
        <p>CRT_TERMINAL_V1.0</p>
        <p class="blink">PRESS START TO INITIALIZE</p>
        <button id="start-btn">INITIALIZE SYSTEM</button>
        <p class="keyboard-hints">
            PC CONTROLS: ← → ARROWS TO MOVE | SHIFT = FIRE | SHIFT+A = AUTO-FIRE | M = MUTE | SPACE = PAUSE
        </p>
    </div>
</div>

<script>
    /**
     * RETRO CRT INTERACTIVE TERMINAL
     * ------------------------------
     * Built with raw HTML5 Canvas and Web Audio API.
     * * Core systems:
     * 1. AudioEngine: Generates procedural sounds (oscillators, noise).
     * 2. ParticleSystem: Manages ambient dust and touch repulsion.
     * 3. GameLoop: Manages the "Space Defender" logic (Ship, Bullets, Enemies).
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const fpsDisplay = document.getElementById('fps-counter');
    const audioStatusDisplay = document.getElementById('audio-status');
    const scoreDisplay = document.getElementById('score');
    const waveDisplay = document.getElementById('wave');
    const startOverlay = document.getElementById('start-overlay');
    const startBtn = document.getElementById('start-btn');

    let width, height;
    let particles = [];
    let bullets = [];
    let enemies = [];
    let explosions = [];
    let score = 0;
    let wave = 1;
    let gameActive = false;
    let gamePaused = false;
    let lastTime = 0;
    let isMuted = false;
    
    // Keyboard state for PC controls
    const keys = {
        left: false,
        right: false,
        shift: false
    };
    
    // Movement distance for keyboard (larger for PC - increased for faster movement)
    const KEYBOARD_MOVE_SPEED = 18;
    
    // Auto-fire state
    let autoFireEnabled = false;
    const AUTO_FIRE_RATE = 150; // milliseconds between auto-fire shots
    const LINE_OF_SIGHT_WIDTH = 80; // Width of the detection zone for auto-fire
    let lastAutoFireTime = 0;
    
    // Helper function to check if firing is allowed based on rate limiting
    function canFire(timestamp) {
        return timestamp - lastAutoFireTime > AUTO_FIRE_RATE;
    }
    
    // Player State
    const player = {
        x: 0,
        y: 0,
        width: 40,
        height: 20,
        color: '#39ff14',
        targetX: 0
    };

    // --- AUDIO ENGINE (Web Audio API) ---
    const AudioEngine = {
        ctx: null,
        isInit: false,
        masterGain: null,
        ambienceOsc: null,
        ambienceGain: null,

        init() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            
            // Create master gain for mute control
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = isMuted ? 0 : 1;
            
            this.isInit = true;
            audioStatusDisplay.innerText = isMuted ? "MUTED" : "ONLINE";
            this.playAmbience();
        },

        setMute(muted) {
            isMuted = muted;
            if (this.masterGain) {
                this.masterGain.gain.setValueAtTime(muted ? 0 : 1, this.ctx.currentTime);
            }
            audioStatusDisplay.innerText = muted ? "MUTED" : "ONLINE";
        },

        toggleMute() {
            this.setMute(!isMuted);
        },

        // Suspend audio when game is paused
        suspend() {
            if (this.ctx && this.ctx.state === 'running') {
                this.ctx.suspend();
            }
        },

        // Resume audio when game is unpaused
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },

        // Procedural Shoot Sound (Frequency Sweep)
        playShoot() {
            if (!this.isInit || gamePaused) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.type = 'square'; // Retro 8-bit feel
            osc.frequency.setValueAtTime(800, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);

            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        },

        // Procedural Explosion (Filtered Noise)
        playExplosion() {
            if (!this.isInit || gamePaused) return;
            const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate White Noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;

            const gain = this.ctx.createGain();
            // Lowpass filter to make it sound like a deep boom
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
            filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.4);

            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            noise.start();
        },

        // Background Hum
        playAmbience() {
            if (!this.isInit) return;
            this.ambienceOsc = this.ctx.createOscillator();
            this.ambienceGain = this.ctx.createGain();
            this.ambienceOsc.type = 'sine';
            this.ambienceOsc.frequency.value = 60; // 60Hz mains hum
            this.ambienceGain.gain.value = 0.02; // Very quiet

            this.ambienceOsc.connect(this.ambienceGain);
            this.ambienceGain.connect(this.masterGain);
            this.ambienceOsc.start();
        }
    };


    // --- RESIZE HANDLING ---
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        player.y = height - 80; // Position player near bottom
        player.targetX = width / 2;
        player.x = width / 2;
        
        // Repopulate particles if screen changes drastically
        if (particles.length < 50) initParticles();
    }
    window.addEventListener('resize', resize);


    // --- PARTICLE SYSTEM (The "Dust") ---
    class Particle {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.vx = (Math.random() - 0.5) * 0.5; // Slow drift
            this.vy = (Math.random() - 0.5) * 0.5;
            this.size = Math.random() * 2 + 0.5;
            this.alpha = Math.random() * 0.5 + 0.1;
            this.friction = 0.98;
        }

        update(interactionX, interactionY, isInteracting) {
            // Apply ambient drift
            this.x += this.vx;
            this.y += this.vy;

            // Screen wrap
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;

            // Interaction: Move away from tap
            if (isInteracting) {
                const dx = this.x - interactionX;
                const dy = this.y - interactionY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = 200; // Radius of effect

                if (dist < maxDist) {
                    const force = (maxDist - dist) / maxDist; // Stronger closer
                    const angle = Math.atan2(dy, dx);
                    const push = 15 * force; // Push strength

                    this.vx += Math.cos(angle) * push * 0.1;
                    this.vy += Math.sin(angle) * push * 0.1;
                }
            }

            // Apply friction to return to normal speed
            this.vx *= this.friction;
            this.vy *= this.friction;
            
            // Min speed floor to keep them moving
            if(Math.abs(this.vx) < 0.2) this.vx += (Math.random()-0.5)*0.01;
            if(Math.abs(this.vy) < 0.2) this.vy += (Math.random()-0.5)*0.01;
        }

        draw(ctx) {
            ctx.fillStyle = `rgba(57, 255, 20, ${this.alpha})`;
            ctx.fillRect(this.x, this.y, this.size, this.size); // Square pixels
        }
    }

    function initParticles() {
        particles = [];
        // More particles on larger screens
        const count = Math.min((width * height) / 4000, 200); 
        for (let i = 0; i < count; i++) {
            particles.push(new Particle());
        }
    }

    // --- GAME ENTITIES ---

    class Bullet {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 4;
            this.height = 10;
            this.speed = 10;
            this.active = true;
        }
        update() {
            this.y -= this.speed;
            if (this.y < 0) this.active = false;
        }
        draw(ctx) {
            ctx.fillStyle = '#39ff14';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#39ff14';
            ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor() {
            this.width = 30;
            this.height = 30;
            this.x = Math.random() * (width - this.width);
            this.y = -50;
            this.speed = Math.random() * 2 + 1 + (wave * 0.2); // Speed increases with wave
            this.active = true;
            // Simple sprite shape data (1 = pixel, 0 = empty)
            this.shape = [
                [1,0,1,1,0,1],
                [0,1,1,1,1,0],
                [1,1,0,0,1,1],
                [1,0,1,1,0,1]
            ];
        }
        update() {
            this.y += this.speed;
            if (this.y > height) this.active = false;
        }
        draw(ctx) {
            ctx.fillStyle = '#39ff14';
            const pixelSize = this.width / 6;
            
            for(let r=0; r<4; r++){
                for(let c=0; c<6; c++){
                    if(this.shape[r][c]){
                        ctx.fillRect(this.x + c*pixelSize, this.y + r*pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }
    }

    class Explosion {
        constructor(x, y) {
            this.particles = [];
            for(let i=0; i<8; i++){
                this.particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5)*8,
                    vy: (Math.random()-0.5)*8,
                    life: 1.0
                });
            }
        }
        update() {
            this.particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
            });
            this.particles = this.particles.filter(p => p.life > 0);
        }
        draw(ctx) {
            ctx.fillStyle = '#fff'; // Flash white
            this.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 4, 4);
                ctx.globalAlpha = 1;
            });
        }
    }


    // --- INPUT HANDLING ---
    let input = { x: 0, y: 0, isDown: false, tapped: false };

    function handleInputStart(e) {
        input.isDown = true;
        input.tapped = true;
        updateInputCoords(e);
        // Player moves to touch X
        player.targetX = input.x;
    }

    function handleInputMove(e) {
        if (!input.isDown) return;
        updateInputCoords(e);
        player.targetX = input.x;
    }

    function handleInputEnd(e) {
        input.isDown = false;
    }

    function updateInputCoords(e) {
        if (e.touches) {
            input.x = e.touches[0].clientX;
            input.y = e.touches[0].clientY;
        } else {
            input.x = e.clientX;
            input.y = e.clientY;
        }
    }

    // Attach listeners
    window.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);
    
    window.addEventListener('touchstart', (e) => { handleInputStart(e); }, {passive: false});
    window.addEventListener('touchmove', (e) => { e.preventDefault(); handleInputMove(e); }, {passive: false});
    window.addEventListener('touchend', handleInputEnd);

    // --- KEYBOARD HANDLING (PC Controls) ---
    const autoFireNotificationEl = document.getElementById('auto-fire-notification');
    
    function showAutoFireNotification(enabled) {
        const text = enabled ? '[ AUTO-FIRE: ON ]' : '[ AUTO-FIRE: OFF ]';
        autoFireNotificationEl.textContent = text;
        autoFireNotificationEl.classList.remove('fade-out');
        autoFireNotificationEl.classList.add('visible');
        
        // Auto-hide after 1.5 seconds with fade out
        setTimeout(() => {
            autoFireNotificationEl.classList.add('fade-out');
            setTimeout(() => {
                autoFireNotificationEl.classList.remove('visible', 'fade-out');
            }, 300);
        }, 1500);
    }
    
    function toggleAutoFire() {
        autoFireEnabled = !autoFireEnabled;
        showAutoFireNotification(autoFireEnabled);
    }
    
    // Check if there are targets in line of sight (vertically above the player)
    function hasTargetsInLineOfSight() {
        const playerCenterX = player.x;
        const halfLineOfSight = LINE_OF_SIGHT_WIDTH / 2;
        
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (enemy.active && enemy.y < player.y) {
                // Check if enemy is within the line of sight (vertical column above player)
                const enemyCenterX = enemy.x + enemy.width / 2;
                if (Math.abs(enemyCenterX - playerCenterX) < halfLineOfSight) {
                    return true;
                }
            }
        }
        return false;
    }
    
    function handleKeyDown(e) {
        // Enter key to start game from start screen (when game is not active)
        if (e.key === 'Enter' && !gameActive) {
            e.preventDefault();
            startGame();
            return;
        }

        // M key to toggle mute
        if (e.key === 'm' || e.key === 'M') {
            e.preventDefault();
            AudioEngine.toggleMute();
            return;
        }

        // Space key to pause/unpause during gameplay
        if (e.key === ' ' && gameActive) {
            e.preventDefault();
            togglePause();
            return;
        }
        
        // Shift+A or Alt+A to toggle auto-fire
        if ((e.key === 'a' || e.key === 'A') && (e.shiftKey || e.altKey) && gameActive) {
            e.preventDefault();
            toggleAutoFire();
            return;
        }
        
        // Shift key to fire bullets
        if (e.key === 'Shift') {
            e.preventDefault();
            keys.shift = true;
        }

        // Arrow keys for movement (PC)
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            keys.left = true;
        }
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            keys.right = true;
        }
    }

    function handleKeyUp(e) {
        if (e.key === 'Shift') {
            e.preventDefault();
            keys.shift = false;
        }
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            keys.left = false;
        }
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            keys.right = false;
        }
    }

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // --- GAME STATE FUNCTIONS ---
    function startGame() {
        if (!AudioEngine.isInit) {
            AudioEngine.init();
        }
        startOverlay.style.display = 'none';
        gameActive = true;
        gamePaused = false;
        lastTime = performance.now();
        
        // Log game start event for telemetry
        if (typeof GameTelemetry !== 'undefined') {
            GameTelemetry.logGameEvent('game_started', { wave: wave, score: score });
        }
        
        loop(lastTime);
    }

    function togglePause() {
        gamePaused = !gamePaused;
        if (gamePaused) {
            // Suspend audio immediately when pausing
            AudioEngine.suspend();
            // Log pause event
            if (typeof GameTelemetry !== 'undefined') {
                GameTelemetry.logGameEvent('game_paused', { wave: wave, score: score });
            }
        } else {
            // Resume audio when unpausing
            AudioEngine.resume();
            // Log resume event
            if (typeof GameTelemetry !== 'undefined') {
                GameTelemetry.logGameEvent('game_resumed', { wave: wave, score: score });
            }
        }
    }


    // --- MAIN GAME LOOP ---
    function loop(timestamp) {
        const dt = timestamp - lastTime;
        lastTime = timestamp;
        
        // Telemetry FPS monitoring
        if (typeof GameTelemetry !== 'undefined' && gameActive && !gamePaused) {
            GameTelemetry.monitorFPS();
        }

        // FPS Calculation
        if (timestamp % 10 === 0) fpsDisplay.innerText = Math.round(1000/dt);

        // Clear Canvas (with slight trail for CRT feel? No, straight clear is cleaner for pixel art)
        ctx.clearRect(0, 0, width, height);

        // Update Dust Particles always (for visual effect even when paused)
        particles.forEach(p => p.update(input.x, input.y, input.isDown));

        // Draw Particles (Background)
        particles.forEach(p => p.draw(ctx));

        // Skip game logic if paused but still render current state
        if (gamePaused) {
            // Draw pause indicator
            ctx.fillStyle = '#39ff14';
            ctx.font = '48px VT323';
            ctx.textAlign = 'center';
            ctx.fillText('// PAUSED //', width / 2, height / 2);
            ctx.font = '24px VT323';
            ctx.fillText('Press SPACE to resume', width / 2, height / 2 + 40);
            ctx.textAlign = 'left';
            
            // Still render game entities in paused state
            renderGameEntities();
            
            requestAnimationFrame(loop);
            return;
        }

        // 1. Logic
        
        // Keyboard movement for PC (larger distance)
        if (keys.left) {
            player.targetX -= KEYBOARD_MOVE_SPEED;
        }
        if (keys.right) {
            player.targetX += KEYBOARD_MOVE_SPEED;
        }
        
        // Clamp targetX to screen bounds
        if (player.targetX < 20) player.targetX = 20;
        if (player.targetX > width - 20) player.targetX = width - 20;
        
        // Player Movement (Lerp for smoothness)
        player.x += (player.targetX - player.x) * 0.15;
        // Clamp player
        if(player.x < 20) player.x = 20;
        if(player.x > width - 20) player.x = width - 20;

        // Spawn Enemies
        if (gameActive && Math.random() < 0.015 * wave) {
            enemies.push(new Enemy());
        }

        // Shooting - supports multiple methods
        let shouldFire = false;
        
        // Touch/click tap to fire
        if (input.tapped && gameActive) {
            shouldFire = true;
            input.tapped = false; // Reset tap
        }
        
        // Shift key to fire (PC control) with rate limiting
        if (keys.shift && gameActive && canFire(timestamp)) {
            shouldFire = true;
            lastAutoFireTime = timestamp;
        }
        
        // Auto-fire when enabled and targets are in line of sight
        if (autoFireEnabled && gameActive && canFire(timestamp) && hasTargetsInLineOfSight()) {
            shouldFire = true;
            lastAutoFireTime = timestamp;
        }
        
        // Execute the fire
        if (shouldFire) {
            bullets.push(new Bullet(player.x, player.y));
            AudioEngine.playShoot();
        }

        // Update Bullets
        bullets.forEach(b => b.update());
        bullets = bullets.filter(b => b.active);

        // Update Enemies
        enemies.forEach(e => e.update());
        
        // Collision Detection
        enemies.forEach(e => {
            bullets.forEach(b => {
                if(b.active && e.active && 
                   b.x > e.x && b.x < e.x + e.width &&
                   b.y > e.y && b.y < e.y + e.height) {
                    
                    e.active = false;
                    b.active = false;
                    score += 100;
                    scoreDisplay.innerText = score.toString().padStart(4, '0');
                    AudioEngine.playExplosion();
                    explosions.push(new Explosion(e.x + e.width/2, e.y + e.height/2));

                    // Wave progression
                    if(score > wave * 1000) {
                        const oldWave = wave;
                        wave++;
                        waveDisplay.innerText = wave.toString().padStart(2, '0');
                        
                        // Log wave progression for telemetry
                        if (typeof GameTelemetry !== 'undefined') {
                            GameTelemetry.logGameEvent('wave_completed', { 
                                previousWave: oldWave, 
                                newWave: wave, 
                                score: score 
                            });
                        }
                    }
                }
            });
        });

        // Cleanup inactive enemies
        enemies = enemies.filter(e => e.active);

        // Update Explosions
        explosions.forEach(exp => exp.update());
        explosions = explosions.filter(exp => exp.particles.length > 0);

        // 2. Rendering
        renderGameEntities();

        requestAnimationFrame(loop);
    }

    // Separate render function for game entities (used in paused and active states)
    function renderGameEntities() {
        if (gameActive) {
            // Draw Player
            ctx.fillStyle = player.color;
            // Simple Ship Shape
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(player.x - 20, player.y + 20);
            ctx.lineTo(player.x + 20, player.y + 20);
            ctx.fill();

            // Draw Bullets
            bullets.forEach(b => b.draw(ctx));

            // Draw Enemies
            enemies.forEach(e => e.draw(ctx));

            // Draw Explosions
            explosions.forEach(exp => exp.draw(ctx));
            
            // Draw Floor Line
            ctx.strokeStyle = '#39ff14';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, height - 10);
            ctx.lineTo(width, height - 10);
            ctx.stroke();
        }
    }

    // --- INITIALIZATION ---
    resize();
    initParticles();
    
    // Start Button Handler
    startBtn.addEventListener('click', () => {
        startGame();
    });

    // --- TELEMETRY INTEGRATION ---
    // Log game events for debugging and optimization
    function logGameTelemetry(eventName, data = {}) {
        if (typeof GameTelemetry !== 'undefined') {
            GameTelemetry.logGameEvent(eventName, data);
        }
    }
    
    // Monitor FPS during gameplay
    function updateTelemetryFPS() {
        if (typeof GameTelemetry !== 'undefined' && gameActive && !gamePaused) {
            GameTelemetry.monitorFPS();
        }
    }
    
    // Track page visibility for session analysis
    document.addEventListener('visibilitychange', function() {
        if (typeof GameTelemetry !== 'undefined') {
            if (document.hidden) {
                GameTelemetry.logGameEvent('page_hidden', { wave: wave, score: score, gameActive: gameActive });
            } else {
                GameTelemetry.logGameEvent('page_visible', { wave: wave, score: score, gameActive: gameActive });
            }
        }
    });
    
    // Track when user leaves the page
    window.addEventListener('beforeunload', function() {
        if (typeof GameTelemetry !== 'undefined') {
            GameTelemetry.logGameEvent('session_ended', { 
                finalWave: wave, 
                finalScore: score,
                gameWasActive: gameActive
            });
        }
    });

</script>
<script src="js/telemetry.js"></script>
</body>
</html>
